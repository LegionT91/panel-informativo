<!DOCTYPE html>
<html lang="es">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Panel Informativo - Príncipe de Gales</title>
    <link href="https://fonts.googleapis.com/css?family=Montserrat:700,400&display=swap" rel="stylesheet">
    <link href="https://fonts.googleapis.com/icon?family=Material+Icons" rel="stylesheet">
    <link href="https://cdn.jsdelivr.net/npm/bootstrap-icons@1.11.0/font/bootstrap-icons.css" rel="stylesheet">
    <link rel="stylesheet" href="{{ url_for('static', filename='main_panel/style.css') }}">
    <style>
    /* Animaciones bounce para rotación */
    @keyframes bounceIn {
        0% { opacity: 0; transform: translateY(18px); }
        50% { opacity: 1; transform: translateY(-6px); }
        80% { transform: translateY(2px); }
        100% { transform: translateY(0); }
    }
    @keyframes bounceInSmall {
        0% { opacity: 0; transform: translateY(10px); }
        60% { opacity: 1; transform: translateY(-3px); }
        85% { transform: translateY(1px); }
        100% { transform: translateY(0); }
    }
    .bounce-in {
        animation: bounceIn 800ms cubic-bezier(.22,.61,.36,1) both;
        will-change: transform, opacity;
    }
    .bounce-in-small {
        animation: bounceInSmall 700ms cubic-bezier(.22,.61,.36,1) both;
        will-change: transform, opacity;
    }

    /* Ken Burns/idle animations (subtle background zoom/pan to keep the screen alive) */
    @keyframes kbZoomIn {
        0% { transform: scale(1); background-position: 50% 50%; }
        100% { transform: scale(1.18); background-position: 50% 50%; }
    }
    @keyframes kbZoomOut {
        0% { transform: scale(1.18); background-position: 50% 50%; }
        100% { transform: scale(1); background-position: 50% 50%; }
    }
    @keyframes kbPanLeft {
        0% { background-position: 54% 50%; }
        100% { background-position: 46% 50%; }
    }
    @keyframes kbPanRight {
        0% { background-position: 46% 50%; }
        100% { background-position: 54% 50%; }
    }
    /* Main card idle variants */
    .kb-main-zoom-in { animation: kbZoomIn 8s ease-in-out infinite alternate; }
    .kb-main-zoom-out { animation: kbZoomOut 8s ease-in-out infinite alternate; }
    .kb-main-pan-left { animation: kbPanLeft 14s ease-in-out infinite alternate; }
    .kb-main-pan-right { animation: kbPanRight 14s ease-in-out infinite alternate; }
    /* Side card idle variants (shorter, slightly faster) */
    .kb-side-zoom-in { animation: kbZoomIn 7s ease-in-out infinite alternate; }
    .kb-side-zoom-out { animation: kbZoomOut 7s ease-in-out infinite alternate; }
    .kb-side-pan-left { animation: kbPanLeft 10s ease-in-out infinite alternate; }
    .kb-side-pan-right { animation: kbPanRight 10s ease-in-out infinite alternate; }

    /* Dedicated background layer to ensure zoom/pan is visible regardless of other styles */
    .main-card, .side-card { position: relative; overflow: hidden; background: transparent !important; animation: none !important; transform: none !important; }
    .main-card::before, .side-card::before {
        content: "";
        position: absolute;
        top: 0; left: 0; right: 0; bottom: 0;
        background-image: var(--bg-url);
        background-size: cover;
        background-position: center;
        background-repeat: no-repeat;
        transform-origin: center;
        will-change: transform, background-position;
        backface-visibility: hidden;
        pointer-events: none;
        z-index: 0;
    }
    /* Ensure text overlays stay above */
    .main-card-overlay, .side-card-overlay { position: relative; z-index: 1; }

    /* Bind idle variants to the ::before layer */
    .kb-main-zoom-in::before { animation: kbZoomIn 9s ease-in-out infinite alternate; animation-delay: var(--kb-offset, 0s); }
    .kb-main-zoom-out::before { animation: kbZoomOut 9s ease-in-out infinite alternate; animation-delay: var(--kb-offset, 0s); }
    .kb-main-pan-left::before { animation: kbPanLeft 9s ease-in-out infinite alternate; animation-delay: var(--kb-offset, 0s); }
    .kb-main-pan-right::before { animation: kbPanRight 9s ease-in-out infinite alternate; animation-delay: var(--kb-offset, 0s); }
    .kb-side-zoom-in::before { animation: kbZoomIn 8s ease-in-out infinite alternate; animation-delay: var(--kb-offset, 0s); }
    .kb-side-zoom-out::before { animation: kbZoomOut 8s ease-in-out infinite alternate; animation-delay: var(--kb-offset, 0s); }
    .kb-side-pan-left::before { animation: kbZoomIn 8s ease-in-out infinite alternate; animation-delay: var(--kb-offset, 0s); }
    .kb-side-pan-right::before { animation: kbZoomIn 8s ease-in-out infinite alternate; animation-delay: var(--kb-offset, 0s); }
    </style>
</head>
<body>
    <div class="header">
        <div class="left-section">
            <div class="logo-area">
                <img class="logo" src="{{ url_for('static', filename='main_panel/img/logo.png') }}" alt="Logo Colegio">
                <div>
                    <div class="school-name">Complejo Educacional<br>Príncipe de Gales</div>
                </div>
            </div>
        </div>
        <div class="center-section">
            <div class="time" id="hora-actual"></div>
        </div>
        <div class="right-section">
            <div class="weather-info">
                <i class="bi {{ clima.icono_bootstrap }} weather-icon" id="icono-clima"></i>
                <div class="weather-details">
                    <span class="temperature" id="temperatura-actual">{{ clima.temperatura_actual }}°C</span>
                    <span class="weather-description" id="descripcion-clima">{{ clima.descripcion }}</span>
                </div>
            </div>
            <span class="date" id="fecha-actual"></span>
        </div>
    </div>
    <div class="main-content">
        <div class="main-card" style="--bg-url:url('{{ main_card.imagen_url }}');">
            <div class="main-card-overlay">
                {% if main_card.id == 'empty_database' %}
                <div class="empty-state" data-aviso-id="{{ main_card.id or '' }}">
                    <i class="bi bi-newspaper empty-icon"></i>
                    <div class="empty-message">{{ main_card.titulo|safe }}</div>
                    <div class="empty-subtitle">El contenido se actualizará automáticamente</div>
                </div>
                {% elif main_card.id and main_card.id.startswith('error_') %}
                <div class="error-state" data-aviso-id="{{ main_card.id or '' }}">
                    <i class="bi bi-exclamation-triangle error-icon"></i>
                    <div class="error-message">{{ main_card.titulo|safe }}</div>
                    <div class="error-subtitle">
                        {% if error_type == 'database_connection' %}
                            Verifica que el servidor de base de datos esté funcionando
                        {% elif error_type == 'database_auth' %}
                            Revisa las credenciales de la base de datos
                        {% elif error_type == 'database_not_found' %}
                            La base de datos no existe o no está configurada
                        {% elif error_type == 'table_not_found' %}
                            La tabla de noticias no existe en la base de datos
                        {% elif error_type == 'connection_refused' %}
                            El servidor de base de datos no está disponible
                        {% else %}
                            Error técnico - contacta al administrador
                        {% endif %}
                    </div>
                </div>
                {% else %}
                <div class="main-card-text" data-aviso-id="{{ main_card.id or '' }}">
                    {{ main_card.titulo|safe }}
                </div>
                <div id="dynamic-badge" class="main-card-badge" style="position:absolute;bottom:16px;right:16px;background:rgba(0,0,0,0.65);color:#fff;padding:12px 18px;border-radius:10px;font-weight:800;font-size:32px;line-height:1.1;letter-spacing:0.2px;box-shadow:0 4px 12px rgba(0,0,0,0.25);">
                    {{ main_card.etiqueta_fecha or '' }}
                </div>
                {% endif %}
            </div>
        </div>
        <div class="side-cards">
            {% for evento in eventos %}
            <div class="side-card" data-aviso-id="{{ evento.id or '' }}" style="--bg-url:url('{{ evento.imagen_url }}');">
                <div class="side-card-overlay">
                    <div class="side-card-date">
                        {{ evento.fecha_inicio }} - {{ evento.fecha_fin }}
                    </div>
                    <div class="side-card-title">
                        {{ evento.titulo }}
                    </div>
                </div>
            </div>
            {% endfor %}
        </div>
    </div>
    <script src="{{ url_for('static', filename='main_panel/script.js') }}"></script>
    <script>
    // Rotación automática de avisos (main + side cards)
    (function() {
        // Preparar datos desde el servidor
        const mainCard = {{ main_card|tojson }};
        const eventosData = {{ eventos|tojson }};
        const rotables = [mainCard, ...eventosData];

        if (!Array.isArray(rotables) || rotables.length === 0) return;

        // Utilidades
        function parseDateFromAny(input) {
            if (!input) return null;
            try {
                if (typeof input === 'string') {
                    const s = input.trim();
                    if (!s) return null;
                    
                    // DD/MM/YYYY or DD/MM/YYYY HH:MM
                    const m = /^([0-3]?\d)\/(0?\d|1[0-2])\/(\d{4})(?:\s+([0-2]?\d):([0-5]?\d))?$/.exec(s);
                    if (m) {
                        const day = parseInt(m[1], 10);
                        const month = parseInt(m[2], 10);
                        const year = parseInt(m[3], 10);
                        const hh = m[4] ? parseInt(m[4], 10) : 0;
                        const mm = m[5] ? parseInt(m[5], 10) : 0;
                        
                        // Validar rangos
                        if (day < 1 || day > 31 || month < 1 || month > 12 || year < 1900 || year > 2100) {
                            return null;
                        }
                        if (hh < 0 || hh > 23 || mm < 0 || mm > 59) {
                            return null;
                        }
                        
                        const date = new Date(year, month - 1, day, hh, mm, 0, 0);
                        return isNaN(date.getTime()) ? null : date;
                    }
                    
                    // ISO-like YYYY-MM-DD[ T]HH:MM[:SS]
                    let iso = s.replace(' ', 'T');
                    if (/^\d{4}-\d{2}-\d{2}([T\s].*)?$/.test(iso)) {
                        const timePart = iso.split('T')[1];
                        if (timePart && timePart.length === 5) iso += ':00';
                        const d = new Date(iso);
                        return isNaN(d.getTime()) ? null : d;
                    }
                    
                    // Fallback con validación
                    const d2 = new Date(s);
                    return isNaN(d2.getTime()) ? null : d2;
                } else if (input instanceof Date) {
                    return isNaN(input.getTime()) ? null : input;
                }
                return null;
            } catch (error) {
                console.warn('Error parseando fecha:', input, error);
                return null;
            }
        }

        function formatDDMMYYYY(date) {
            if (!(date instanceof Date) || isNaN(date.getTime())) return '';
            const dd = String(date.getDate()).padStart(2, '0');
            const mm = String(date.getMonth() + 1).padStart(2, '0');
            const yyyy = String(date.getFullYear());
            return `${dd}/${mm}/${yyyy}`;
        }
        function setMainCard(item) {
            try {
                const mainCardEl = document.querySelector('.main-card');
                const overlayEl = document.querySelector('.main-card-overlay');
                const textEl = document.querySelector('.main-card-text');
                
                if (!mainCardEl || !overlayEl || !textEl) {
                    console.warn('Elementos del main card no encontrados');
                    return;
                }

                // Validar item
                if (!item || typeof item !== 'object') {
                    console.warn('Item inválido para main card:', item);
                    return;
                }

                // Configurar imagen de fondo con fallback
                const bg = item.imagen_url || item.imagen || '/static/main_panel/img/logo.png';
                try {
                    mainCardEl.style.removeProperty('background-image');
                    mainCardEl.style.setProperty('--bg-url', `url('${bg}')`);
                } catch (bgError) {
                    console.warn('Error configurando imagen de fondo:', bgError);
                    mainCardEl.style.setProperty('--bg-url', `url('/static/main_panel/img/logo.png')`);
                }

                // Configurar texto con sanitización
                const titulo = (item.titulo || item.title || 'Sin título').toString();
                textEl.innerHTML = titulo.replace(/[<>]/g, ''); // Sanitización básica

                // Badge dinámico con mejor manejo de errores
                let badgeText = '';
                try {
                    // Preferir etiqueta generada por backend
                    if (item.etiqueta_fecha && typeof item.etiqueta_fecha === 'string') {
                        badgeText = item.etiqueta_fecha;
                    } else if (item.fecha_inicio) {
                        // Calcular proximidad desde fecha de inicio respecto a "hoy"
                        const start = parseDateFromAny(item.fecha_inicio);
                        if (start && !isNaN(start.getTime())) {
                            const today = new Date();
                            const startDate = new Date(start.getFullYear(), start.getMonth(), start.getDate());
                            const todayDate = new Date(today.getFullYear(), today.getMonth(), today.getDate());
                            const msPerDay = 24 * 60 * 60 * 1000;
                            const delta = Math.round((startDate - todayDate) / msPerDay);
                            
                            if (delta === 0) {
                                badgeText = 'Hoy';
                            } else if (delta === 1) {
                                badgeText = 'Mañana';
                            } else if (delta > 1 && delta <= 30) {
                                badgeText = `${delta} días`;
                            } else {
                                // Mostrar solo la fecha de inicio en formato dd/mm/yyyy
                                badgeText = formatDDMMYYYY(start);
                            }
                        }
                    }
                } catch (dateError) {
                    console.warn('Error calculando fecha para badge:', dateError);
                }

                // Crear o actualizar badge
                let badgeEl = overlayEl.querySelector('#dynamic-badge');
                if (!badgeEl) {
                    try {
                        badgeEl = document.createElement('div');
                        badgeEl.id = 'dynamic-badge';
                        badgeEl.className = 'main-card-badge';
                        badgeEl.style.position = 'absolute';
                        badgeEl.style.bottom = '16px';
                        badgeEl.style.right = '16px';
                        badgeEl.style.background = 'rgba(0,0,0,0.65)';
                        badgeEl.style.color = '#fff';
                        badgeEl.style.padding = '12px 18px';
                        badgeEl.style.borderRadius = '10px';
                        badgeEl.style.fontWeight = '800';
                        badgeEl.style.fontSize = '32px';
                        badgeEl.style.lineHeight = '1.1';
                        badgeEl.style.letterSpacing = '0.2px';
                        badgeEl.style.boxShadow = '0 4px 12px rgba(0,0,0,0.25)';
                        overlayEl.appendChild(badgeEl);
                    } catch (badgeError) {
                        console.warn('Error creando badge:', badgeError);
                        return;
                    }
                }
                
                badgeEl.textContent = badgeText || '';
                badgeEl.style.display = badgeText ? 'block' : 'none';
            } catch (e) {
                console.error('Error crítico actualizando main card:', e);
                // Fallback: mostrar contenido básico
                try {
                    const textEl = document.querySelector('.main-card-text');
                    if (textEl) {
                        textEl.innerHTML = 'Error cargando contenido';
                    }
                } catch (fallbackError) {
                    console.error('Error en fallback:', fallbackError);
                }
            }
        }

        function renderSideCards(startIndex) {
            try {
                const container = document.querySelector('.side-cards');
                if (!container) {
                    console.warn('Container de side cards no encontrado');
                    return;
                }
                
                if (!Array.isArray(rotables) || rotables.length === 0) {
                    console.warn('No hay datos rotables disponibles');
                    return;
                }
                
                const n = rotables.length;
                const items = [];
                const maxSideCards = 3;
                
                // Mostrar los 3 siguientes a partir de startIndex (excluyendo el main actual)
                for (let i = 1; i <= Math.min(maxSideCards, n - 1); i++) {
                    const idx = (startIndex + i) % n;
                    const item = rotables[idx];
                    if (item && typeof item === 'object') {
                        items.push(item);
                    }
                }
                
                const html = items.map((ev, index) => {
                    try {
                        // Validar y sanitizar datos
                        const bg = (ev.imagen_url || ev.imagen || '/static/main_panel/img/logo.png').replace(/[<>'"]/g, '');
                        const titulo = (ev.titulo || ev.title || 'Sin título').toString().replace(/[<>]/g, '');
                        const avisoId = (ev.id || `fallback_${index}`).toString().replace(/[<>'"]/g, '');
                        
                        // Calcular etiqueta de fecha con manejo de errores
                        let etiqueta = '';
                        try {
                            if (ev.etiqueta_fecha && typeof ev.etiqueta_fecha === 'string') {
                                etiqueta = ev.etiqueta_fecha;
                            } else if (ev.fecha_inicio) {
                                const start = parseDateFromAny(ev.fecha_inicio);
                                if (start && !isNaN(start.getTime())) {
                                    const today = new Date();
                                    const startDate = new Date(start.getFullYear(), start.getMonth(), start.getDate());
                                    const todayDate = new Date(today.getFullYear(), today.getMonth(), today.getDate());
                                    const msPerDay = 24 * 60 * 60 * 1000;
                                    const delta = Math.round((startDate - todayDate) / msPerDay);
                                    
                                    if (delta === 0) etiqueta = 'Hoy';
                                    else if (delta === 1) etiqueta = 'Mañana';
                                    else if (delta > 1 && delta <= 30) etiqueta = `${delta} días`;
                                    else etiqueta = formatDDMMYYYY(start);
                                }
                            }
                            
                            if (!etiqueta && ev.fecha_fin) {
                                const end = parseDateFromAny(ev.fecha_fin);
                                if (end && !isNaN(end.getTime())) {
                                    etiqueta = formatDDMMYYYY(end);
                                }
                            }
                        } catch (dateError) {
                            console.warn('Error calculando fecha para side card:', dateError);
                        }
                        
                        return `
                            <div class="side-card" data-aviso-id="${avisoId}" style="--bg-url:url('${bg}');">
                                <div class="side-card-overlay">
                                    <div class="side-card-date">${etiqueta}</div>
                                    <div class="side-card-title">${titulo}</div>
                                </div>
                            </div>
                        `;
                    } catch (itemError) {
                        console.warn('Error procesando item de side card:', itemError);
                        return `
                            <div class="side-card" data-aviso-id="error_${index}" style="--bg-url:url('/static/main_panel/img/logo.png');">
                                <div class="side-card-overlay">
                                    <div class="side-card-date">Error</div>
                                    <div class="side-card-title">Error cargando</div>
                                </div>
                            </div>
                        `;
                    }
                }).join('');
                
                container.innerHTML = html;
            } catch (e) {
                console.error('Error crítico actualizando side cards:', e);
                // Fallback: mostrar mensaje de error
                try {
                    const container = document.querySelector('.side-cards');
                    if (container) {
                        container.innerHTML = `
                            <div class="side-card" style="--bg-url:url('/static/main_panel/img/logo.png');">
                                <div class="side-card-overlay">
                                    <div class="side-card-date">Error</div>
                                    <div class="side-card-title">Error cargando noticias</div>
                                </div>
                            </div>
                        `;
                    }
                } catch (fallbackError) {
                    console.error('Error en fallback de side cards:', fallbackError);
                }
            }
        }

        let current = 0;
        // Estado para idle variations
        let lastMainIdleClass = '';

        function applyIdleVariationMain() {
            const main = document.querySelector('.main-card');
            if (!main) return;
            // limpiar posibles clases kb-main-*
            ['kb-main-zoom-in','kb-main-zoom-out','kb-main-pan-left','kb-main-pan-right'].forEach(c => main.classList.remove(c));
            lastMainIdleClass = 'kb-main-zoom-in';
            main.classList.add('kb-main-zoom-in');
            // delay negativo suave
            main.style.setProperty('--kb-offset', '-0.15s');
        }

        function applyIdleVariationSideCards() {
            const sideCards = document.querySelectorAll('.side-card');
            sideCards.forEach((el, i) => {
                ['kb-side-zoom-in','kb-side-zoom-out','kb-side-pan-left','kb-side-pan-right'].forEach(c => el.classList.remove(c));
                el.classList.add('kb-side-zoom-in');
                const offsets = [-0.06, -0.12, -0.18, -0.24];
                el.style.setProperty('--kb-offset', offsets[i % offsets.length] + 's');
            });
        }

        function renderAll() {
            setMainCard(rotables[current]);
            renderSideCards(current);
            // Animar elementos
            try {
                const mainText = document.querySelector('.main-card-text');
                const badge = document.getElementById('dynamic-badge');
                const sideCards = document.querySelectorAll('.side-card-overlay');

                const restart = (el, cls) => {
                    if (!el) return;
                    el.classList.remove(cls);
                    // forzar reflow para reiniciar la animación
                    void el.offsetWidth;
                    el.classList.add(cls);
                };

                restart(mainText, 'bounce-in');
                if (badge) restart(badge, 'bounce-in');
                sideCards.forEach((el, i) => {
                    // Pequeño escalonado para un efecto agradable
                    setTimeout(() => restart(el, 'bounce-in-small'), i * 120);
                });
            } catch (e) { /* noop */ }

            // Aplicar variaciones de idle (zoom/pan) para mantener vida en pantalla
            applyIdleVariationMain();
            applyIdleVariationSideCards();
        }

        // Render inicial
        document.addEventListener('DOMContentLoaded', function() {
            renderAll();
            // Intervalo de rotación (10s)
            setInterval(function() {
                current = (current + 1) % rotables.length;
                renderAll();
            }, 10000);
        });
    })();
    </script>
</body>
</html>